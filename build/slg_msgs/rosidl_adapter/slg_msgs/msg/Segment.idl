// generated from rosidl_adapter/resource/msg.idl.em
// with input from slg_msgs/msg/Segment.msg
// generated code does not contain a copyright notice

#include "geometry_msgs/msg/Point.idl"

module slg_msgs {
  module msg {
    module Segment_Constants {
      @verbatim (language="comment", text=
        "Type of the labels")
      const uint32 BACKGROUND = 0;
      const uint32 PERSON = 1;
      const uint32 PERSON_CANE = 2;
      const uint32 PERSON_WHEEL_CHAIR = 3;
    };
    @verbatim (language="comment", text=
      "Message for sorted segment of points.")
    struct Segment {
      @verbatim (language="comment", text=
        "Each segment is assigned an id, which uniquely identifies the segment consistently across multiple frames." "\n"
        "The segments can be linked to previous and next segment using lastPointPriorSeg and firstPointNextSeg, respectively." "\n"
        "Segment messages can be used as an input to a classifier such as a person detector, or for annotating" "\n"
        "sensor_msgs/Laserscan messages with groundtruth person tracks." "\n"
        "Id of the segment")
      @default (value=0)
      uint64 id;

      @verbatim (language="comment", text=
        "Label of the segment")
      @default (value=0)
      uint32 label;

      @verbatim (language="comment", text=
        "Angular distance to the closest boundary (in rads)")
      @default (value=0.0)
      double angular_distance;

      @verbatim (language="comment", text=
        "Last point of the previous segment")
      geometry_msgs::msg::Point last_point_prior_segment;

      @verbatim (language="comment", text=
        "First point of the next segment")
      geometry_msgs::msg::Point first_point_next_segment;

      @verbatim (language="comment", text=
        "Points per segment")
      sequence<geometry_msgs::msg::Point> points;
    };
  };
};
